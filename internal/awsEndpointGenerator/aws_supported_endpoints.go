// This package generates Go files containing AWS service-supported endpoints
// and service ID constants. These files are useful for determining AWS service
// availability across regions or fetching supported services programmatically.

package main

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"regexp"
	"strings"
	"text/template"
)

// URL for fetching AWS endpoints JSON data.
const endpointsJSONURL = "https://raw.githubusercontent.com/aws/aws-sdk-go-v2/master/codegen/smithy-aws-go-codegen/src/main/resources/software/amazon/smithy/aws/go/codegen/endpoints.json"

// ServiceIDTemplateData holds service keys for generating service ID constants.
type ServiceIDTemplateData struct {
	ServiceKeys []string
}

// Partition represents an AWS partition in the JSON data.
type Partition struct {
	ID          string             `json:"partition"`
	Name        string             `json:"partitionName"`
	DNSSuffix   string             `json:"dnsSuffix"`
	RegionRegex *regexp.Regexp     `json:"regionRegex"`
	Regions     map[string]Region  `json:"regions"`
	Services    map[string]Service `json:"services"`
}

// Region represents an AWS region.
type Region struct {
	ID          string `json:"id"`
	Description string `json:"description"`
}

// Service represents an AWS service with its endpoints.
type Service struct {
	Endpoints map[string]Endpoint `json:"endpoints"`
}

// Endpoint represents an individual endpoint for a service.
type Endpoint struct {
	CredentialScope *CredentialScope `json:"credentialScope"`
	Hostname        string           `json:"hostname"`
	Deprecated      bool             `json:"deprecated,omitempty"`
	Variants        []Variant        `json:"variants,omitempty"`
}

// CredentialScope defines the credential scope for an endpoint.
type CredentialScope struct {
	Region string `json:"region"`
}

// Variant represents a variant of an endpoint with additional metadata.
type Variant struct {
	Hostname string   `json:"hostname"`
	Tags     []string `json:"tags"`
}

// EndpointsData is the root structure of the JSON data.
type EndpointsData struct {
	Partitions []Partition `json:"partitions"`
}

// TemplateData holds partitions data for generating Go files.
type TemplateData struct {
	Partitions []Partition
}

func main() {
	// Generate the AWS Service supported Endpoints
	if err := Generate(); err != nil {
		fmt.Printf("Error generating Service supported endpoint file: %v\n", err)
	}

	if err := GenerateServiceID(); err != nil {
		fmt.Printf("Error generating Service IDs file: %v\n", err)
	}
}


// Generate fetches endpoint data from AWS and generates a Go file with service-supported endpoints.
func Generate() error {
	data, err := fetchJSON(endpointsJSONURL)
	if err != nil {
		return fmt.Errorf("error fetching JSON: %w", err)
	}

	var endpoints EndpointsData
	if err := json.Unmarshal(data, &endpoints); err != nil {
		return fmt.Errorf("error parsing JSON: %w", err)
	}

	templateData := &TemplateData{Partitions: endpoints.Partitions}
	outputFile := "aws/endpoint_list_gen.go"
	if err := generateGoFile(outputFile, *templateData); err != nil {
		return fmt.Errorf("error generating Go file: %w", err)
	}

	fmt.Printf("Go file generated: %s\n", outputFile)
	return nil
}

// GenerateServiceID generates a Go file with service ID constants.
func GenerateServiceID() error {
	data, err := fetchJSON(endpointsJSONURL)
	if err != nil {
		return fmt.Errorf("error fetching JSON: %w", err)
	}

	var endpoints EndpointsData
	if err := json.Unmarshal(data, &endpoints); err != nil {
		return fmt.Errorf("error parsing JSON: %w", err)
	}

	// Extract unique service keys
	serviceKeys := extractUniqueServiceKeys(endpoints)
	templateData := &ServiceIDTemplateData{ServiceKeys: serviceKeys}
	outputFile := "aws/endpoint_service_ids_gen.go"

	if err := generateGoFileForServiceID(outputFile, *templateData); err != nil {
		return fmt.Errorf("error generating service ID file: %w", err)
	}

	fmt.Printf("Go file generated: %s\n", outputFile)
	return nil
}

// fetchJSON fetches JSON data from a given URL.
func fetchJSON(url string) ([]byte, error) {
	resp, err := http.Get(url)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	return io.ReadAll(resp.Body)
}

// extractUniqueServiceKeys extracts unique service keys from the EndpointsData.
func extractUniqueServiceKeys(endpoints EndpointsData) []string {
	serviceKeys := make(map[string]struct{})
	for _, partition := range endpoints.Partitions {
		for key := range partition.Services {
			serviceKeys[key] = struct{}{}
		}
	}

	var keys []string
	for key := range serviceKeys {
		keys = append(keys, key)
	}
	return keys
}

// generateGoFile generates a Go file with AWS-supported endpoints.
func generateGoFile(filename string, data TemplateData) error {
	const tmpl = `// Code generated by awsEndpointGenerator; DO NOT EDIT.

package aws

import "regexp"

// Partition represents an AWS partition in the JSON data.
type Partition struct {
	ID          string             ` + "`json:\"partition\"`" + `
	Name        string             ` + "`json:\"partitionName\"`" + `
	DNSSuffix   string             ` + "`json:\"dnsSuffix\"`" + `
	RegionRegex *regexp.Regexp     ` + "`json:\"regionRegex\"`" + `
	Regions     map[string]Region  ` + "`json:\"regions\"`" + `
	Services    map[string]Service ` + "`json:\"services\"`" + `
}

// Region represents an AWS region.
type Region struct {
	ID          string ` + "`json:\"id\"`" + `
	Description string ` + "`json:\"description\"`" + `
}

// Service represents an AWS service with its endpoints.
type Service struct {
	Endpoints map[string]Endpoint ` + "`json:\"endpoints\"`" + `
}

// Endpoint represents an individual endpoint for a service.
type Endpoint struct {
	CredentialScope *CredentialScope ` + "`json:\"credentialScope\"`" + `
	Hostname        string           ` + "`json:\"hostname\"`" + `
	Deprecated      bool             ` + "`json:\"deprecated,omitempty\"`" + `
	Variants        []Variant        ` + "`json:\"variants,omitempty\"`" + `
}

// CredentialScope defines the credential scope for an endpoint.
type CredentialScope struct {
	Region string ` + "`json:\"region\"`" + `
}

// Variant represents a variant of an endpoint with additional metadata.
type Variant struct {
	Hostname string   ` + "`json:\"hostname\"`" + `
	Tags     []string ` + "`json:\"tags\"`" + `
}

// EndpointsData is the root structure of the JSON data.
type EndpointsData struct {
	Partitions []Partition ` + "`json:\"partitions\"`" + `
}

// Partition definitions
{{range .Partitions}}
// {{.Name}} Partition
var {{toConstant .ID}}Partition = Partition{
	ID:          "{{.ID}}",
	Name:        "{{.Name}}",
	DNSSuffix:   "{{.DNSSuffix}}",
	RegionRegex: regexp.MustCompile(` + "`{{.RegionRegex}}`" + `),
	Regions: map[string]Region{
		{{range $key, $region := .Regions}}
		"{{$key}}": {ID: "{{$key}}", Description: "{{$region.Description}}"},
		{{end}}
	},
	Services: map[string]Service{
		{{range $key, $service := .Services}}
		"{{$key}}": {
			Endpoints: map[string]Endpoint{
				{{range $endpointKey, $endpoint := $service.Endpoints}}
				"{{$endpointKey}}": {
					Hostname: "{{$endpoint.Hostname}}",
					{{if $endpoint.CredentialScope}}CredentialScope: &CredentialScope{Region: "{{$endpoint.CredentialScope.Region}}"},{{end}}
					{{if $endpoint.Deprecated}}Deprecated: true,{{end}}
				},
				{{end}}
			},
		},
		{{end}}
	},
}
{{end}}
`

	return renderTemplate(filename, tmpl, data)
}

// generateGoFileForServiceID generates a Go file with service ID constants.
func generateGoFileForServiceID(filename string, data ServiceIDTemplateData) error {
	const tmpl = `// Code generated by awsEndpointGenerator; DO NOT EDIT.

package aws

// Service constants
{{range .ServiceKeys}}
const AWS_{{toConstant .}}_SERVICE_ID = "{{.}}"
{{end}}
`
	return renderTemplate(filename, tmpl, data)
}

// renderTemplate writes data to a file based on a template.
func renderTemplate(filename, tmpl string, data interface{}) error {
	funcMap := template.FuncMap{
		"toConstant": func(key string) string {
			key = strings.ReplaceAll(key, ".", "_")
			return strings.ToUpper(strings.ReplaceAll(key, "-", "_"))
		},
	}

	t := template.Must(template.New("template").Funcs(funcMap).Parse(tmpl))
	file, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer file.Close()

	return t.Execute(file, data)
}
